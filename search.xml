<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[markdown]]></title>
      <url>/2017/09/15/markdown.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="Brief-Introduction-of-MarkDown"><a href="#Brief-Introduction-of-MarkDown" class="headerlink" title="Brief Introduction of MarkDown"></a>Brief Introduction of MarkDown</h1><blockquote>
<p>It is common that we have to write a passage, but so many times<br>we are in the troubles of nice arrangement of style.</p>
<p><strong>MarkDown</strong> is a way to solve the problem, what we need is only simple<br>hints. Let’s begin the study of <strong>MarkDown</strong>.</p>
</blockquote>
<hr>
<h3 id="General-Description"><a href="#General-Description" class="headerlink" title="General Description"></a>General Description</h3><ol>
<li><p>if there is a block element, we need two blanks before and after the<br>contents.</p>
</li>
<li><p>if there is only a inline element, we need just write one by one.</p>
</li>
<li><p>Indent. Indent have meanning of these: <code>&lt;pre&gt;&lt;/pre&gt;</code> or child element.</p>
</li>
<li><p>if the sign has meaning in md , we have to use <code>\</code> to eacape.   </p>
</li>
</ol>
<h3 id="Block-Element"><a href="#Block-Element" class="headerlink" title="Block Element"></a>Block Element</h3><ol>
<li><p>passage <code>&lt;p&gt;&lt;/p&gt;</code><br>According to general rule we only need two blanks before and after contents.</p>
</li>
<li><p>line break <code>&lt;br /&gt;</code><br>We can break the line personnally. Just two or more spaces at the <strong>end</strong> of line</p>
</li>
<li><p>horizontal tags <code>&lt;hr /&gt;</code><br> we put three or more   signs as  <code>----- or _____</code>, but we need blanks</p>
</li>
<li><p>blockquote <code>&lt;blockquote&gt;&lt;/blockquote&gt;</code><br>we need <code>&gt; or &gt;&gt;</code> according structure. For example:</p>
<pre><code> &gt;  This is demo of blockquote        
 &gt;
 &gt;&gt; This is block inside the outer blockquote
 &gt;
 &gt;1. item1
 &gt;   
 &gt;   * unordered list 
</code></pre></li>
<li><p>header <code>&lt;h1&gt; &lt;h2&gt; &lt;h3&gt; &lt;h4&gt; &lt;h5&gt; &lt;h6&gt;</code><br>we need <code>#</code> for <code>&lt;h1&gt;</code> and similar for the others. </p>
</li>
<li><p>ordered list <code>&lt;ol&gt;</code><br>we use <code>just number</code>. if we do need a number like <code>12. 32</code>, we need <code>\</code><br>to escape like  <code>12\. 32</code>. </p>
</li>
<li><p>unorder list <code>&lt;ul&gt;</code><br>we can use <code>+ or - or *</code>;</p>
</li>
<li><p>code block <code>&lt;pre&gt;&lt;/pre&gt;</code><br>Indent every line of the block by at least 4 spaces or 1 tab.</p>
</li>
<li><p>fenced code block<br>As I use in the article, just use <code>``content`` or  ```content``` </code> </p>
</li>
<li><p>table <code>&lt;table&gt;&lt;/table&gt;</code>  </p>
<pre><code>|name |age  |address|
|:---:|:---:| :---: |   // : means way of alignment
|lee  | 25  | Wuhan |
</code></pre></li>
</ol>
<h2 id="Inline-Elements"><a href="#Inline-Elements" class="headerlink" title="Inline Elements"></a>Inline Elements</h2><ol>
<li><p>ordinary link <code>&lt;a&gt;&lt;/a&gt;</code><br>we use like this <code>[link text](url &#39;optional title&#39;)</code> or <code>[link text][id] [id]: url &quot;optional text&quot;</code></p>
</li>
<li><p>image link ‘<img>‘<br>Same as orinary link except we use  <code>!</code> link <code>![alt text](url &#39;optional text&#39;)</code></p>
</li>
<li><p>just url<br>we just use as <code>&lt;http://mzlee.site&gt;</code> or <code>&lt;mailto: nucliliangmin@163.com&gt;</code> </p>
</li>
<li><p>emphysis <code>&lt;em&gt;&lt;/em&gt;</code>or strong <code>&lt;strong&gt;&lt;/strong&gt;</code><br>one <code>*content*</code> means <code>&lt;em&gt;content&lt;/em&gt;</code>, two means the last.</p>
</li>
<li><p>strikethrough <code>&lt;del&gt;&lt;/del&gt;</code><br>we use <code>~~content~~</code>, <del>contnet</del></p>
</li>
</ol>
<h2 id="html-tag"><a href="#html-tag" class="headerlink" title="html tag"></a>html tag</h2><p>sure, we can use html tags as we usually. There is a problem : MarkDown is useless<br>when in block elements.</p>
]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[今日畅怀]]></title>
      <url>/2017/09/14/job.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>温馨提示：打开音乐阅读更佳喔</p>
<h3 id="开胃菜"><a href="#开胃菜" class="headerlink" title="开胃菜"></a>开胃菜</h3><p>没有什么能够阻挡，我对自由的向往！<br>既自以心为形役，奚惆怅而独悲？我想最重要的大抵是意志的自由吧。</p>
<div id="aplayer0" class="aplayer" style="margin-bottom: 20px;"></div>
		<script>
			new APlayer({
				element: document.getElementById("aplayer0"),
				narrow: false,
				autoplay: false,
				showlrc: 0,
				music: {
					title: "蓝莲花",
					author: "许巍",
					url: "../../../../../media/许巍 - 蓝莲花.mp3",
					pic: "../../../../../img/lanlianhua.jpg",
				}
			});
		</script>
<h3 id="说说找工作"><a href="#说说找工作" class="headerlink" title="说说找工作"></a>说说找工作</h3><p>时间还真是过得有点快。我刚进校的时候寝室的学长们正在找工作，现在轮到我了，恍如昨日。我不禁想起了《匆匆》。</p>
<p>找工作要先投简历，然后是各种的在线测评，有测编程的（这个是必须，程序员不测这个测什么）；有测性格的，本来也是无可厚非，就像找女朋友也得互相了解嘛。<br>不过有些测评是王二娘的裹脚–又长又臭，嘿你还得选；比如你得从每个都很消极没一个符合你的选项中选出一个来，这样真有意义吗?你当然可以不填，但是你得找工作，所以你必须选。企业当然是想找能干活的人，不过就这么赤裸裸的展示出企业内部的所谓文化真的好吗?</p>
<p>以上是吐槽，不过谁叫我没有工作呢，该投的简历还得投，该做的测评还得做。虽说做了也不一定有结果，但是还得做。我觉得找工作就像找女朋友，还得看缘分。</p>
<p>我曾听过学校中诸如赵小龙、姚欣等学长的故事，也曾幻想着自己某一天也会成为那样的人。现在看来，我只不过是个普普通通的我，这是事实。我丝毫不会因此而不安了，因为我就是我，他们有他们的传奇，我有我的人生。</p>
<h3 id="说说我对未来的看法"><a href="#说说我对未来的看法" class="headerlink" title="说说我对未来的看法"></a>说说我对未来的看法</h3><p>未来必定会超乎我的想象，这个世界变化太快，太精彩了。我出生的时候村里还没有电话，电视机还很少，有也是黑白的。上小学的时候零星有人用手机，那时的他们还故意将手机别在腰间，生怕别人看不见。现在小学生都在用手机，可能性能比阿波罗登月时的计算机的计算能力还要好。比起缅怀过去，我更愿意拥抱未来。</p>
<p>现在流行词汇是大数据、云计算、人工智能…<br>可是我们的对未来的想象或许好太局限，我们并无法预见那翻天覆地的变化，然而这是生活给我们的惊喜。</p>
<p>我期望着在不远的未来万物互联，万物智能，彻底打通人与物、物与物的连接。这是一个多大的市场，这里面有多大的机遇，有多少的变革。更重要的是，这对生产力的促进有多大。有句话不是说世界最遥远的距离是红绿灯和摄像头的距离，它们都站在路口，但却从未交流过。我想某一天人类会专注于创造性的工作，彻底从繁重的劳动中解放。这不就是共产主义吗，有意思。</p>
<p>说回现实。在一段时间，该干的事情还是有认认真真做好。力求精益求精。一件事要么不干，要么就把事情尽力做到最好。因为我个人的起点低，意味着我有很大的进步空间为没有什么牵绊，我可以大胆往前探索，看看我能走多远。嗯，听着蓝莲花还真是有点激情。</p>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 工作 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title></title>
      <url>/2017/08/04/demo.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
 <script>
     window.onload = function () {
         function add (a,b,c) {
            arguments[1] = 1;
            console.log(a,b,c);
         }
         add(2,3);
     }
 </script>
<link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
<body>
 test part
</body>
</html>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[基础知识]]></title>
      <url>/2017/08/04/basic.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h3><p> 函数虽是对象返回”function”,null返回“object”。<br> 可对未申明的变量使用却不会报错，返回“undefined”。</p>
<h3 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h3><p>值仅有undefined表示对象声明后未初始化，null == undefined</p>
<h3 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h3><p>值仅有null。空对象指针，若一个变量将来用于放对象就要先设为null,以后检查是否已放对象。</p>
<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>值是：true/false。各种数据类型值都可以转换为布尔值，转换使用Boolean()函数。流控制语句隐式调用该函数做转换以确定执行方式。<br>Object\Symbol对应的布尔值永远是true。</p>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>只有这一种类型，包含数字、NaN、Infinity.可使用科学计算法。字面量有十进制、八进制(0开头，严格模式失效)、16进制。计算转为十进制计算。存在舍入误差，<br>从而不要测试浮点数的值。</p>
<p>范围：Number.MAX_VALUE Num.MIN_VALUE。isFinite()来确定是否在范围之中。</p>
<p>NaN：1、涉及后均返回NaN 2、任何值与之不相等，包括自身。isNaN()函数先对传入的值使用Number()转型，转为数字是false,是NaN为true.</p>
<p>对象的valueOf没重写下为本身，toString()方法Array类型是逗号接字符串，对象是”[object Object]”。</p>
<p>Number()不支持八进制字符串转换，parseInt（）可以指定基数，parseFloat()只解析十进制。 </p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>由16位的Unicode字符系列组成，有时需要转义。null、undefined无toString方法，因为没有原型链。可用String()转型（有toSttring()先用，然后补充null和undefined这两个特殊值）</p>
<p>Boolean()\Number()\String()可做显式的转型函数。</p>
]]></content>
      
        <categories>
            
            <category> JS高级程序设计 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础语法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[BOM]]></title>
      <url>/2017/08/03/bom.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>JS由ECMAScript、DOM、BOM,在浏览器中BOM是核心。以前BOM并无标准，基于浏览器之间的互操作性，存在许多共通的地方。</p>
<h2 id="window-对象"><a href="#window-对象" class="headerlink" title="window 对象"></a>window 对象</h2><p>window对象既是js操作浏览器的接口，也是全局对象。它有许多好用的函数：parseInt()、parseFloat()、setTimeout()、setInterval()<br>getComputedStyle()、encodeURIComponent()、decodeURIComponent()、alert()、confirm()、prompt()、isFinite()、isNaN()等方法可以在页面中直接使用。</p>
<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>严格模式下函数调用方式的this为undefined,非严格模式下是window。页面中定义的全局的函数、变量等直接作为window的属性，但是[[configurable]]=false<br>也就是说不能直接用<code>delete window.x</code>的方式删除。而直接设定的window属性可以删除。若未申明变量就引用会报错，但是不存在的属性通过window的方式就<br>返回undefined。</p>
<p>window对象有document\location\history\navigator\screen等属性。windows mobil平台IE不支持直接在window对象中添加属性。</p>
<h3 id="窗口关系及框架"><a href="#窗口关系及框架" class="headerlink" title="窗口关系及框架"></a>窗口关系及框架</h3><p>每个窗口、框架、或是打开的标签都拥有window对象，且对象之间是相互独立的。框架层次上有self、parent、top。最外层的window对象可用框架集frames用<br>索引或是框架名称的方式访问框架。框架集中含有的<frame src=" " name="">其中的name属性值可以是<a>target中值，从而在哪个框架中打开。window对象<br>有许多层次,如：window.parent.parent.frames可以到top的框架集。由于不同框架之间的window对象互不相关，所以在框架间传递的对象使用instanceof方法存在问题。<br>instanceof方法在自身的window对象下的原型链中实施。</a></p>
<h3 id="窗口位置。"><a href="#窗口位置。" class="headerlink" title="窗口位置。"></a>窗口位置。</h3><ol>
<li>window.screenLeft/window.screenTop 除firefox均支持</li>
<li>window.screenX/window.screenY firefox等的方式。</li>
</ol>
<p>以上两种方式不同浏览器在计算上有所不同。最终的结果就是无法跨浏览器或的浏览器窗口左上角的位置。但是moveTo()、moveBy()可以在弹窗中移动位置，而<br>主要的窗口却会被禁。</p>
<h3 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h3><p>window.outterHeight和window.outterWidth在浏览器上存在差异，chrome的window.innerWidth与window.outterWidth同。无法跨浏览器获得窗口大小。但可以获得页面视口大小。<br>可用resizeTo()、resizeBy()调整，但是可能被禁。</p>
<pre><code>            var pagewidth = window.innerWidth, pageheight = window.innerHeight;
                    if (typeof pagewidth !== &quot;number&quot;) {
                    if (document.compatMode == &quot;CSS1Compat&quot;) {
                    pagewidth = document.documentElement.clientWidth;
                    pageheight = document.documentElement.clientHeight;
             } else {
            pagewidth =  document.body.clientWidth;
            pageheight =  document.body.clientHeight;
                 }
            }
</code></pre><p>在移动端上:</p>
<pre><code>       可见视口：
         var width = window.innerWidth;     
         var height = window.innerHeight;
      IE:
        var width = document.documentElement.clientWidth; 
        var height = document.documentElement.clientHeight;

     布局视口：
        var width = document.documentElement.clientWidth;；     
        var height = document.documentElement.clientHeight;
      IE:
         pagewidth =  document.body.clientWidth;
         pageheight =  document.body.clientHeight;
</code></pre><h3 id="导航和打开窗口"><a href="#导航和打开窗口" class="headerlink" title="导航和打开窗口"></a>导航和打开窗口</h3><p>window.open(url,name,feature,boolean);在不打开窗口下，boolean表示是否取代当前的历史记录。window.open返回指向新窗口对象的引用。含有opener和<br>closed属性。opener指向打开它的对象。</p>
<p>安全限制：存在浏览器内置程序或是插件阻止弹窗插件阻止返回null,插件阻住可能抛出错误。</p>
<pre><code> var blocked = false;
try {
 var a = window.open(&quot;http://example.com&quot;);
 if (a == null) {
 blocked = true
   }
 }  catch (err) {
       blocked = true;
 } 
</code></pre><h3 id="间歇调用和超时调用"><a href="#间歇调用和超时调用" class="headerlink" title="间歇调用和超时调用"></a>间歇调用和超时调用</h3><p>   二者均有唯一ID可结束执行，推荐用setTimeout()模拟setInterval();setInterval()可能在前个调用未完成时就开始了。两个函数的第一个参数不推荐用字符串。</p>
<h3 id="系统对话框"><a href="#系统对话框" class="headerlink" title="系统对话框"></a>系统对话框</h3><p> window.alert()\confirm()返回布尔值\prompt()返回null或是字符串。它们是同步模态的。一次操作打开两个以上的对话框会在第二个后有复选框来确认后需屏蔽。<br> 空闲时会将对话框计数器清零。</p>
<h2 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h2><p>用于获得文件信息或是url信息，有：protocol、search、href、host、hostname、pathname、hash、port。       </p>
<p>提取查询字符串信息：<br>      function querysearch () {<br>         var qs = (location.search.length &gt; 0 ) : location.search.substring(1) : “”;<br>         var args = {};<br>         var name.value,len,item,con;<br>         var items = qs.split(“&amp;”);<br>         len = items.length;<br>         for (var i = 0; i &lt; len;i ++) {<br>         con = items[i].split(“=””);<br>         name = con[0].value = con[1];<br>          if (name &amp;&amp; args[name] == undefined) {<br>              args[name] = value;<br>             }<br>            }<br>         return args;<br>         }</p>
<p>  通过location.href可以到另一页面，但是有历史记录。可使用location.replace()。这样就不会有记录。location.reload()重新加载。</p>
<h2 id="navagator"><a href="#navagator" class="headerlink" title="navagator"></a>navagator</h2><p> 用于了解浏览器的信息。</p>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>  navigator.plugins是个集合，含有refresh（）方法，反映最新安装插件情况，可选布尔值来说明是否要刷新页面。<br>  每项有name\description\filename\length.</p>
<pre><code>  function hasPlugin (name) {
    name = name.toLowerCase();
    for (var i =0 ; i &lt; navigator.plugins.length; i++) {
       if (navigator.plugins[i].name.toLowerCase().indexOf(name) !== -1) {
          return true;
        }
      } 
     return false; 
  }

  IE浏览器： name为COM标识
  function hasIEPlugins (name) {
     try {
          new ActiveXObject(name);
          return true; 
     } catch (err) {
          return false;
       }
  }
</code></pre><h3 id="注册处理程序"><a href="#注册处理程序" class="headerlink" title="注册处理程序"></a>注册处理程序</h3><p>navigator.registerContentHandler()/navigator.registerProtocolHandler(),支持3种MIME类型。 </p>
<h2 id="screen-对象"><a href="#screen-对象" class="headerlink" title="screen 对象"></a>screen 对象</h2><p>有用的是其中的screen.availWidth和屏幕大小的screen.width的像素值。</p>
<h2 id="history对象"><a href="#history对象" class="headerlink" title="history对象"></a>history对象</h2><p>每个window对象含有history属性，保存实际的浏览历史记录。但是不能获得浏览过的URL,可以通过go()\back()\forward()方式实现改动。<br>history.go()的负数值表示后退.其中的length表示记录数，第一次进入值为0.            </p>
]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> BOM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo-owl-tag插件测试]]></title>
      <url>/2017/08/02/owl-tag-demo.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="usage"><a href="#usage" class="headerlink" title="usage"></a>usage</h2><p>  这个插件可以支持以下几种视频嵌入，本地及Giphy图片资源的引入。</p>
<pre><code>       {% owl youtube youtube_id %}
       {% owl niconico niconico_id [type] %}
       {% owl bilibili bilibili_id [page] %}
       {% owl vimeo vimeo_id %}
       {% owl tudou tudou_id %}
       {% owl youku youku_id %}
       {% owl tencent tencent_id %}
       {% owl ted ted_id [lang] %}
</code></pre><hr>
<h4 id="gighy图片"><a href="#gighy图片" class="headerlink" title="gighy图片"></a>gighy图片</h4>  <div class="owl-media owl-image owl-giphy"><img src="https://media.giphy.com/media/BqMusBHZqmMvK/giphy.gif"></div>           
<hr>
<h4 id="TED"><a href="#TED" class="headerlink" title="TED"></a>TED</h4><div class="owl-media owl-video owl-ted"><iframe src="https://embed.ted.com/talks/ben_dunlap_talks_about_a_passionate_life" width="640" height="360" frameborder="0" scrolling="no" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreenframeborder="0" allowfullscreen></iframe>         
<h4 id="四川的美食"><a href="#四川的美食" class="headerlink" title="四川的美食"></a>四川的美食</h4> <div class="owl-media owl-video owl-bilibili"><embed src="http://static.hdslb.com/miniloader.swf" flashvars="aid=12476692&page=1" pluginspage="http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash" type="application/x-shockwave-flash" quality="high" allowfullscreen="true"></div>
<h4 id="风去云不回"><a href="#风去云不回" class="headerlink" title="风去云不回"></a>风去云不回</h4> <div class="owl-media owl-video owl-tencent"><embed src="http://static.video.qq.com/TPout.swf?vid=g0527rsqk4t&auto=0" type="application/x-shockwave-flash" quality="high" allowfullscreen="true" align="middle" allowscriptaccess="always"></div>
<h4 id="网红"><a href="#网红" class="headerlink" title="网红"></a>网红</h4><div class="owl-media owl-video owl-tudou"><embed src="http://www.tudou.com/v/XMjkyMzQzMjk0MA/&bid=05&resourceId=0_05_05_99/v.swf" allowscriptaccess="always" wmode="opaque" type="application/x-shockwave-flash" quality="high" allowfullscreen="true"></div>
<h4 id="当爱情经过的时候"><a href="#当爱情经过的时候" class="headerlink" title="当爱情经过的时候"></a>当爱情经过的时候</h4><div class="owl-media owl-video owl-youku"><iframe src="http://player.youku.com/embed/XMjgwNjM5Mjg3Mg" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe></div>
</div>]]></content>
      
        <categories>
            
            <category> 技术 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 插件测试 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript 对象]]></title>
      <url>/2017/08/01/js-object.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>对象的属性有属性描述符的对象，即使没有直接给出。</p>
<pre><code>       var obj = {
              name: &#39;objcet&#39;
       };

       Objcet.getOwnpropertyDescriptor(obj, &quot;name&quot;);   // 为：{value: &quot;objcet&quot;, configurable: true, writable: true, enumerable: true}

       //直接给出
       Object.defineProperty(obj, &quot;tool&quot;, {
            value: &quot;tool&quot;
       });

       Objcet.getOwnpropertyDescriptor(obj, &quot;tool&quot;);   // 为：{value: &quot;tool&quot;, configurable: false, writable: false, enumerable: false}
</code></pre><p>这里默认含有一个对象描述符对象。且各项默认为true。我们可以对其进行多项操作。若我直接给出呢？这是若不在对象中明确给出，那么就会默认为false。</p>
<p>1、这四个值重要吗？   value可以直接修改值，writable决定是否可以写入，enumerable决定for in 语句、Objcet.keys()、o.propertyIsEnumerable(),configurable决定是否可以删除属性值以及是否可以配置。</p>
<p>2、 浅复制下不会对原有的描述符的属性进行复制，也就是说其中的值默认为true。    访问器属性：它们与value、writable是冲突的，只能给出一种形式。</p>
<pre><code>         var obj = {
                get value () {
                 return this._value;  
                },
                set value (v) {
                 this._value = v; 
                }
         };
         //这是的value是不可枚举、不可配置的。_value是可以枚举配置的。
</code></pre><p> <strong> 枚举</strong><br> for…in 语句会以[[prototype]]链的方式枚举但枚举的是属性名。</p>
<pre><code>        var arr = [1, 2, 3];
        for (var i in arr) {
        console.log(i);
        }
        //值为：&quot;0&quot;、&quot;1&quot;、&quot;2&quot;
</code></pre><p>另：Object.keys()、Objcet.getOwnPropertyNames()不会查找原型链。</p>
<p><strong>遍历</strong><br>数组内置@@iterator从而可以遍历得到值，对于一个对象可以认为建立@@iteraror来与for of 语句搭配使用。下面是一个例子。         </p>
<pre><code>    var random = {
            [Symbol.iterator]: function () {
                    return {
                          next: function () {
                                 return {
                                        value: Math.random()
                                 }; 
                          }
                    };
            }
    };            
</code></pre>]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JS 对象 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[永远年轻，永远热泪盈眶]]></title>
      <url>/2017/07/26/me.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>这是我在大学时候无意听见老罗的一句话。从此了解他的一些他的经历：关于摆地摊、求职、背单词、教英语。我仍然记得他说的“尽管没有风，五星红旗依然飘扬在上空”，他大哥看《金瓶梅》被批的故事。我觉得很多东西很有趣。</p>
<p>后来我迷上了乐器，学了葫芦丝、口琴，可惜都不精。不过这有啥关系，我又不是音乐家；享受音乐的乐趣就行了。<br>一次，我到一哥们宿舍串门借了他吉他来玩儿。从此我迷上了吉他。我了解了Tommy Emmanuel、小松原俊、岸部真明，特别是pierre Bensusan。我知道了国内的高君以及许岑。我觉得音乐就是一剂安慰剂。</p>
<p>我觉得人活着就要有所追求，不然和咸鱼有什么区别呢？</p>
<p>人首先要解决生存问题，要挣钱；不然谈不上其它。只是不要丢了自己。我们追求美，我希望活得正直、纯粹，简洁。<br>我想去折腾一些我感兴趣的东西，不断拓宽自己。我希望不因岁月而失去了年轻的心。我想去更多地方看一看。</p>
<p>我希望：永远年轻，永远热泪盈眶</p>
<div class="owl-media owl-video owl-tencent"><embed src="http://static.video.qq.com/TPout.swf?vid=f0532e0hz26&auto=0" type="application/x-shockwave-flash" quality="high" allowfullscreen="true" align="middle" allowscriptaccess="always"></div>]]></content>
      
        <categories>
            
            <category> 随想 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 杂想 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[还是那个朴树]]></title>
      <url>/2017/07/26/pu-shu.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><hr>
<h2 id="清白之年"><a href="#清白之年" class="headerlink" title="清白之年"></a>清白之年</h2><p> <img src="../../../../../img/liehu.jpg" alt="清白之年"></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=487590187&auto=0&height=66"></iframe> 

<p>今天的朴树依然<strong>热爱</strong>美丽又遗憾的世界，<br>憎恶有关虚假不真诚的一切，<br>只是他始终没有逃离生活。        </p>
<p>即使世俗的眼光常常会把他遗落在那个白衣飘飘的美好年代。<br>朴树等了十年，<br>花了很多钱，做了很多不喜欢的事，就是为了让更多人陪他分享这张唱片。<br>君归之时依似少年！很好</p>
<hr>
<h3>Baby, До свидания</h3>

<p><img src="../../../../../img/babay.jpg" alt="Baby, До свидания"></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=442869386&auto=0&height=66"></iframe>


<p>朴树的令人欢喜，在于他的诚恳，对人，对音乐。<br>也在于他的纯粹与个性，只用自己的方式爱这个世界，并用心为这世界创造音乐。<br>谢谢朴树，有你在歌唱，真好。</p>
<hr>
<h2 id="那些花儿"><a href="#那些花儿" class="headerlink" title="那些花儿"></a>那些花儿</h2><p><img src="/../../../../../img/naxiehua.jpg" alt="花儿"></p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=139377&auto=0&height=66"></iframe>

<p>在乎的人，重要的事，<br>也能找不到借口地抛之脑后，<br>尽管事后想弥补，打来打去的几个字，<br>想说明自己在乎，<br>却不知能不能是真的传达出去。</p>
<p>我美其名曰地燃烧青春，<br>满脑子都在想未来还有什么疯狂的事还没经历，<br>殊不知可能已经经历了最珍视的那段，又下意识地将之掩藏。<br>夜深了，有点，想你们了；<br>有点，想你了。</p>
]]></content>
      
        <categories>
            
            <category> 音乐 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 朴树 </tag>
            
            <tag> 民谣 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[面朝大海，春暖花开]]></title>
      <url>/2017/07/26/haizi.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p> 从明天起，做一个幸福的人<br> 喂马、劈柴，周游世界<br> 从明天起，关心粮食和蔬菜<br> 我有一所房子，面朝大海，春暖花开  </p>
<p> 从明天起，和每一个亲人通信<br> 告诉他们我的幸福<br> 那幸福的闪电告诉我的<br> 我将告诉每一个人  </p>
<p> 给每一条河每一座山取一个温暖的名字<br> 陌生人，我也为你祝福<br> 愿你有一个灿烂的前程<br> 愿你有情人终成眷属<br> 愿你在尘世获得幸福<br> 我只愿面朝大海，春暖花开</p>
]]></content>
      
        <categories>
            
            <category> 文学 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 海子 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[css层叠]]></title>
      <url>/2016/11/30/css-cascade.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>css通过建立与文档的关联而实施效果。文档结构重要性不言而喻，对于建立良好的内容索引、提高可维护性、较好的可访问性；另，利于css选择器选择、继承机制。 概要地讲,层叠机制是处理对文档上应用样式时解决该应用何种样式的解决方案,涉及到重要性、特殊性、来源、顺序的问题。下面分别说明。</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p> 每条声明都是有特殊性的,其特殊性由选择器组件确定。用户代理会将特殊性赋予给每条声明。由于存在选择器分组和声明分组的情况，用户代理会将它们解组出来的。然后对应个元素可能会有多条规则。这时，若都是针对相同的属性，那使用何种规则呢？这是层叠机制解决的问题。</p>
<h2 id="特殊性"><a href="#特殊性" class="headerlink" title="特殊性"></a>特殊性</h2><p>  特殊性值结构:x,x,x,x。x代表一个自然数。左边比右边的值大。1、内联样式的特殊性为1,0,0,0，其他首位为0。 2、id特殊性为0, 1，0，0。3、伪类、类、属性选择的特殊性为0,0,1,0。4、元素、伪元素特殊性为0,0,0,1。5、继承没有特殊性。结合符没有特殊性。通配符特殊性为0,0,0,0。使用上，当重要性、来源相同条件相同时，特殊性大的获胜。</p>
<h2 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h2><p>重要性真的重要,使用上将!important置于”;”前面就可以了，注意是关键词的最后。用户代理将重要性的分在一组,普通的分在一组,声明冲突时,重要性的占上风。但是重要性不会改变特殊性;就是说重要性分组中出现冲突后,按特殊性来。当然还要考虑来源，一般在权重上是创作人员&gt;用户&gt;用户代理。结合起来权重的顺序是：用户重要声明、创作人员重要声明、创作人员普通声明、用户的普通声明、代理的默认声明。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>就是元素向后代传递属性值的机制,但是未必可靠,与浏览器有关。此外，继承是有限制的，限制了一些与盒模型相关的属性例如：外边距、内边距、背景、边框等问题。它的特殊性不存在，比通配符还要低，所以不要随意使用通配符选择器。</p>
<h2 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h2><p>顺序是指当重要性、来源、特殊性等相同的时候，后面的权重会比前面的权重要大。通常是导入的文件的声明在前面。css2.1中认为内联样式的特殊性为1,0,0,0。css2认为特殊值是0,1,0,0。从顺序上讲，内联样式顺序认为是在后面。</p>
<h2 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h2><p>既然元素上会有多条规则,可能这些声明是关于相同的属性的。由此，需要层叠。  </p>
<ol>
<li>重要性和来源。见上重要性;</li>
<li>考虑特殊性，特殊性大的权重也大;</li>
<li>顺序。顺序在后面的权重大。</li>
</ol>
<h2 id="非css结构"><a href="#非css结构" class="headerlink" title="非css结构"></a>非css结构</h2><p>考虑到html中含有用于控制表现的元素，特殊性上是0,0,0,0。顺序认为在创作人员样式表前面，用户样式表、创作人员样式表会将其覆盖掉，用户代理部可以。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[poem:reserved words]]></title>
      <url>/2016/10/31/poem-reserved.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>Let this long package float,</p>
<p>Goto private class if short.</p>
<p>While protected with debugger case,</p>
<p>Continue volatile interface.</p>
<p>Instanceof super synchronized throw,</p>
<p>Extends final export throws.</p>
<p>Try import double enum?</p>
<p>False, boolean,abstract function,</p>
<p>Implements typeof transient break!</p>
<p>Void static, default do,</p>
<p>Switch int native new.</p>
<p>Else, delete null public var</p>
<p>In return for const, true, char.</p>
<p>Finally catch byte.</p>
]]></content>
      
        <categories>
            
            <category> 随笔 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> reserved words </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS 赋值的问题]]></title>
      <url>/2016/10/28/assignment.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p> 根据值的类型是基本类型值还是复杂类型的值在传递时会有不同。</p>
<p> JS函数的参数传递是按值传递，基本类型值传递的是副本，复杂类型值传递的是引用。从而会影响原来的值，不会改变原来的复制前的引用。</p>
<pre><code>       function foo (x) {
            x += 1;
            console.log(x);
       }

       var a = 3;
       var b = new Number(a);
       foo(a);    //4        复制了3，从而函数中操作不会影响到a指向的值
       console.log(a);  //3
       foo(b);     //4      b是个数字对象，参数传递时传给x的是这个对象的引用。 x += 1; 由于基本类型值是不可变的，首先会从x指向的值中提取出3，最后x神不知鬼不觉的从一个引用变为
                            一个新的数字对象的用。原对象还在那里。

       console.log(b);  //3
</code></pre><p>有时，我只是想去传入一个数组参数，但是却改变了数组的值，这时可以传入对象的副本即可。如：</p>
<pre><code>      var arr = [1, 3, 5];
      function foo (a) {
          return a.push(&quot;end_flag&quot;).join(&quot; &quot;);
      }

      foo(arr);    //这时arr指向的数组也发生了变化。

      foo(arr.slice()); //arr不变
</code></pre>]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[THIS]]></title>
      <url>/2016/10/24/this.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>  我给自己总结一下，this。“this“是一种动态灵活的机制。它在函数调用时确定，与调用方式有关，而非词法作用域。我这里使用DC的说法对应的另一种说法。即函数的this绑定分为隐式绑定、显式绑定、默认绑定、new绑定。下分别说明：</p>
<h2 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h2><p>  就是不加任何修饰的使用函数。 this在非严格模式下绑定在window上，严格模式下绑定于undefined。当然这要在函数体中使用”use strict”;才管用。</p>
<pre><code>       var  foo = function () {
              console.log(this.a); //global
       }; 

       var a = &quot;global value&quot;;
</code></pre><h2 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h2><p>   这种方式是在函数作为对象方法的时候this变为这个对象,但是会出现绑定丢失的情况，因为安置传递后变为了默认绑定的形式。</p>
<pre><code>       var  foo = function () {
              console.log(this.a); //global
       }; 
       var a = &quot;global value&quot;;

       var obj = {
           a: &quot;object&quot;,
           foo: foo
       };

       obj.foo();   //&quot;object&quot;

       //绑定丢失

       var bar = obj.foo;
       bar();    //&quot;global value&quot;;

       //函数传递参数也是按值传递的,从而也会丢失绑定
       setTimeout(obj.foo, 1000) //&quot;global value&quot;;
</code></pre><h2 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h2><p>我直接指定函数调用的this值，当然直接使用apply、call没有问题，若使用bind方法后还是可以被new绑定改变this值。那么如何不让它改变，采用所谓的硬绑定来定。即外加一个包装函数。一些api可直接指定函数调用的this。</p>
<pre><code>  var  foo = function () {
         console.log(this.a); //global
  }; 
  var a = &quot;global value&quot;;

  var obj = {
      a: &quot;object&quot;,
      foo: foo
  };
  foo.apply(obj)  //&quot;object&quot;

  //丢失的例子
  foo = function (v) {
      this.value = v; 
  };
  var boo = foo.bind(obj);
  var bar = new boo(&quot;text&quot;);
  bar.value === &quot;text&quot;   //true
  obj.value === undefined //true

  //加上包装函数使得不可变

  var hardbind = function () {    //无论如何调用外层函数均不会改变
      foo.apply(obj);
  };                   
</code></pre><h2 id="new绑定（略过）"><a href="#new绑定（略过）" class="headerlink" title="new绑定（略过）"></a>new绑定（略过）</h2><h2 id="有趣的问题"><a href="#有趣的问题" class="headerlink" title="有趣的问题"></a>有趣的问题</h2><p>有时我们想借用某个方法，但又不在乎this值那可以使用null、undefined作为参数，但实际上却被绑定在全局对象上，这是始料未及的。见例子。</p>
<pre><code>  function foo (a) {
        this.a = a;
  }
  foo.apply(null, &quot;where&quot;);  //这时的window.a为&quot;where&quot;.  
</code></pre><p> 那我不想改变任何有用的对象怎么办呢？见例子：</p>
<pre><code>      var π = Object.create(null); //我将this定于这里之后，不会对其他任何对象有影响。
</code></pre><p> 我想要一种绑定方式：在默认下不会绑定在undefined或是window,同时又可以在其它绑定下修改this值</p>
<pre><code>            (!Function.prototype.softbind) {
                  Function.prototype.softbind = function (obj) {
                        var fn = this;
                        var curried =Array.prototype.slice.call(arguments, 1);
                        var bound = function () {
                               return fn.apply((!this || this === window) ? obj : this, 
                               curried.concat.apply(curried, arguments));      //关键步骤
                        };
                        bound.prototype = fn.prototype; 
                        return bound; 
                  };
            }

            var obj1 = {name: &quot;obj1&quot;};
            var obj2 = {name: &quot;obj2&quot;};
            var foo = function () {
                   console.log(this.name);
            };
            var ins = foo.softbind(obj1);
            ins();  //&quot;obj1&quot;;
            obj1.foo = ins;
            obj1.foo();  //&quot;obj1&quot;;
            obj2.foo = obj1.foo;
            obj2.foo();    //&quot;obj2&quot;, 因为外层函数执行的this是obj2，这时函数执行时的this不变，为obj2。

            setTimeout(obj2.foo, 1000);  //&quot;obj1&quot;,原因是：obj2.foo传入后变为了默认绑定，bound函数执行的this原本应是window(这里没有使用严格模式)，关键步骤中将对应的this替换为预先
                                         //的obj1。   
</code></pre>]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JS this </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[作用域]]></title>
      <url>/2016/10/16/domain.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="section-1"><a href="#section-1" class="headerlink" title="section 1"></a>section 1</h2><p>JS会在执行之前编译，并采取相应优化例如JIT优化；编译分为分词、语法分析、代码生成过程。</p>
<p>作用域是关于变量（或是标识符）去何处查询以及如何查询的一套规则。分为RHS、LHS查询、RHS找到对应位置且要返回值，LHS查询会找到对应的空间。LHS在非严格模式下在无法找到的情况下在全局对象中建立变量且返回，严格模式下会出错“Reference&amp;nbsp:Error”。简而言之，reference&nbsp;error是作用域判别失败，typeerror是作用域判别成功但是执行操作不当。</p>
<p>作用域包括函数作用域、块级作用域。利用函数作用域可以用来隐藏信息，避免命名冲突（可以为一个编译单元使用一个统一的命名空间，可以使用模块的方式）。但是用函数来封装的问题是什么呢？第一，它会污染作用域；其次，还要显示的调用。那就可以使用IIFE了。</p>
<ol>
<li>函数表达式与函数声明的区别，主要是语句开头的词法单元是不是”function”。若是表达式则可以用()(),(())不同的调用模式了。</li>
<li><p>函数声明是不可以匿名的，函数表达式可以。</p>
<p>匿名函数问题：1、在栈追踪的调试上比较困难；2、在递归运算时不得不使用arguments.callee这种过时的技术。</p>
<p>IIFE作用：1、可以避免污染作用域以及不用显示调用;  2、可以使用所谓的UMD模式。见下面：</p>
<pre><code>        var a = &quot;demo string&quot;;
        (function (def) {
             def(window);
        }(function (global) {
             console.log(global.a);   //&quot;demo string&quot;;  
        }));
</code></pre></li>
</ol>
<h2 id="section-2-块级作用域"><a href="#section-2-块级作用域" class="headerlink" title="section 2 (块级作用域)"></a>section 2 (块级作用域)</h2><p>  1、w ith. 它会将with限定的obj添加到其后代码块的标识符的作用域的前端。</p>
<p>  2、 try/catch的catch分句(es3中就有)。用于在不支持let语句条件下人为建立一个块级作用域。</p>
<pre><code>   //let 语句形式
   let a = 3;
   console.log(a);
   //catch的实现
   {
        try {
              throw 3; 
        } catch (a) {
               console.log(a);
        }
   }
</code></pre><p>  3、 let.let不会提升变量，在垃圾收集、闭包（多是循环等）中有重要的作用。</p>
<p>  4、  const。这个是建立块级的常量。</p>
<pre><code>        {
            const a = &quot;inner&quot;;
            console.log(a);   //&quot;inner&quot; 
        }
        console.log(a);       //reference error;
</code></pre>]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 作用域 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS语言精粹读后体会]]></title>
      <url>/2016/09/07/JS-goodparts.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>先说说JS是容易被误解的语言的观点。从名字上来看，”Java”这似乎暗示着这门语言与Java的关系；好像这门语言是Java的子集，或比Java弱。但实际与Java并无关系，如果说非要有关系，那可以说说一点八卦。当年Netscape确实为了让它快速发展，与Sun公司有过合作；其中为了借大热的Java东风，改名Javascript(原来叫做Livescript).JS第一版仅仅用了10天，未经打磨就广泛使用至今(什么是”网红”，这才是”网红”)。JS不可避免的有许多设计失误，比如全局变量的设计模式。标准的出现是晚于JS的，而且标准也并不”标准”，这导致了许多滥用。由于JS通常是用在web的，从而被认为只能用于浏览器，但它却可以用在服务器等地方的。它的语法类C，但实际上是”披着C外衣的Lisp”，是一种面向对象的函数式编程语言。与传统的面向对象的语言相比，它不是基于类的继承，而是基于原型的继承。</p>
<p>公司是不会让人使用语言的每个特性的，我们要使用那部分最可靠、可维护、方便阅读的成熟的子集。</p>
<p>为什么要使用JS？一方面是没有选择；另一方面是这门语言本身有 它自身的优雅、灵活的地方，具有极强的表达能力。</p>
<p> DC认为JS有许多优秀的想法：函数、弱类型、动态对象、字面量的对象表示法。糟糕的想法是：基于全局变量的编程模式。JS是披着C外衣的Lisp(基于lambda演算的语言，与人工智能极为相关)。<br> 强类型语言可以在编译阶段找到程序的类型错误，弱类型做不到；但通常类型错误不是最主要的问题。弱类型可以让人不必疲于应对造型系统。<br> 对象的字面量表示法很好用，DC也借鉴到了JSON中作为一种代替XML通信的数据传输格式。JS的连接单元是基于全局变量的。编译单元的顶级变量会到全局对象这个公共命名空间。</p>
<hr>
<h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>这章主要讲语法，DC使用了表示形式语法的巴克斯范式图，这的确比语言来得准确简洁。我只想表达一个问题：表达式与表达式语句的关系。因为其他问题很明白。</p>
<p>从DC的巴科斯范式图上大致可以认为，表达式是比表达式语句宽泛的。DC的子集中表达式语句是表达式的真子集。</p>
<p>表达式语句主要用于单个或多个标识符赋值、函数或方法调用、删除对象的属性，语法开头是标识符。</p>
<p>表达式：字面量、标识符、加上圆括号的表达式、prefix+expression、expression+infix+expression、expression+”?”+expression+”:”+expression、expression调用、expressio属性提取、new expression 调用、delete + expression+refinement.<br>具体的巴科斯范式图我就不画了，详见JS语言精粹。</p>
<hr>
<h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><h3 id="基本问题"><a href="#基本问题" class="headerlink" title="基本问题"></a>基本问题</h3><p>JS的数据类型（不是数据结构）分：简单数据类型（undefined\null\boolean\string\number\symbol）、复杂数据类型(object)</p>
<p>对象是可变的键值对的集合，最关键是对象是无类型（class-free）的，也就是说对于新的属性值类型没有要求。属性名可以是name(标识符)、string(包括空字符串)，很适合各类数据管理。最牛逼的机制是对象之间的非传统意义上的继承或是说委托更好一些；可以减少对象初始化的时间和内存。而且这是一种不同于类的新的编程思路。</p>
<p>对象的字面量表示法的属性名类型是字符串，虽然有时候输入的可能并不是字符串，但实际上是被转为了字符串；但若不符合标识符规则时就要显式的使用字符串。这在检索时会表现出来。对象查询属性时若找不到（包括原型链）返回undefined。可以使用”[]”、”.”来获得，符合name规范时使用点访问法；其余使用[]访问法。若已有属性会被覆盖，若不含属性可以新建属性。</p>
<p>对象在堆内存中不会被复制，复制的是对象的引用。所以传递的函数、数组等都是引用而已。</p>
<h3 id="原型链问题"><a href="#原型链问题" class="headerlink" title="原型链问题"></a>原型链问题</h3><p>  原型链是一种内部机制，我在我得第一篇博客已经表达过这个问题。就算根本不设置也会存在。对象有设置对象原型的方法DC原来提出有:</p>
<pre><code>            if ( typeof Object.beget !== &quot;undefined&quot;) {
                  Object.create = function (obj) {
                  function F () {}
                  F.prototype = obj;
                 return new F();    
                  } 
            } 
</code></pre><p> 另外，必须指出一下问题：使用返回的new&nbsp;F()的内部原型链由F.prototype更新。原型关系是一种动态关系，原型链中更新的时候，查找时会对其他立即显示。对象属性的查找先从对象开始，然后会向原型链中查找。可以使用typeof来大致做一下过滤。<br> 可以使用for/in语句来枚举对象的属性，但不能保证出来的顺序；同时还会枚举原型链的。可使typeOf和obj.hasOwnProperty()来过滤。如：</p>
<pre><code>         for （ var key in obj ） {
                if (obj.hasOwnProperty(key)) {
                       if ( typeof key !==&quot;function&quot;) {
                                //代码 
                        }

                 }
         }
</code></pre><p>可以使用delete来删除对象的属性，而不会修改原型链</p>
<h3 id="减少全局变量污染"><a href="#减少全局变量污染" class="headerlink" title="减少全局变量污染"></a>减少全局变量污染</h3><p> 由于JS没有连接器，编译单元的顶级变量会出在全局变量中。为了减少变量污染，可以一个公共的接口来包含全局资源或使用闭包（与词法作用域相关）。</p>
<hr>
<h2 id="四"><a href="#四" class="headerlink" title="四"></a>四</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数是对象，它与其它对象唯一的不同是它可以调用。函数可实现：代码复用、信息隐藏、代码组合调用。建立函数时会建立：上下文、调用函数的代码。每个函数（除Function.prototype）都会有一个原型对象。</p>
<pre><code>function foo ( ) {
     //code
}
  foo.prototype = {constructor:this}; 
</code></pre><p>它必有一个foo.prototype对象，而且这是显含的。函数字面量属于字面量，也就属于表达式的范畴。从而可以使用表达式的地方就可以使用函数字面量。</p>
<p>JS函数的参数是按值传递的。它不会检查传入实参的类型、个数；若实参少于形参实参函数调用时的形参值为undefined.每个函数会this,this在函数执行时才会确定，与函数的调用方式相关（与动态作用域有某种相似）。调用方式分为：方法调用、函数调用、构造器调用、apply调用。</p>
<p>方法调用：也就是说一个函数为某个对象的属性值。那么函数调用时的this到底是哪个？   我要再次强调，对象会有自己默认的原型链，同时我们可以设置对象的prototype属性，但这个属性与内部的原型链相比很弱，对象的”继承”或更确切的说是委托是基于内部原型链的。</p>
<pre><code> var a = {};
   var b = {&quot;name&quot;:&quot;name&quot;};
    a.prototype = b;
   console.log(a.name)    //undefined

 Object.setPrototypeOf(a,b);
 console.log(a.name)   //&quot;name&quot;
</code></pre><p>开始，我直接设置prototype属性，然后以为通过对象的继承可以访问到对象b中的name;事实是：此时a与b的原型链链接到了Object.prototype。接着，我真正修改了原型链，故可以访问到name属性。</p>
<p>那么,这个表面的prototype有何用？   前文提到函数（除Function.prototype）总会有一个对象与之对应。若我建立一个用函数建立一个对象的话，就会有用。新建的对象的原型链中的上一环为构造函数的prototype对象。</p>
<pre><code>function foo () {}
//那么一定有一个foo.prototype对象。
var  b = new foo();
该对象的原型链中就会有 b 的存在
  foo.prototype.isPrototypeOf(b) //true
</code></pre><p> 其三，一般函数的原型链中不含prototype对象。但Function.prototype为function(){},且位于Function的原型链中。<br>   <code>Function.prototype.isPrototypeOf(Function)        //true.</code></p>
<p>  回到刚才的问题，方法调用函数时，对应的this为何值。我直接给出结论，我认为是：可以直接查找到方法的那个对象。直接上代码。</p>
<pre><code>   var a = {&quot;a&quot;:&quot;a&quot;};
           var b = {&quot;b&quot;:&quot;b&quot;};
           var c = {&quot;c&quot;:&quot;c&quot;,
                    &quot;show&quot;:function(){
                        return this;
                    }
                };
            Object.setPrototypeOf(b,c);
            Object.setPrototypeOf(a,b);   
        //现在原型链从a开始到b到c到Object.prototype.

             a.show();         //对象a
             b.show();        //对象b


      //Function的例子

        Function.prototype.method = function (name,func) {
               this.prototype[name] = func;
                 return this; 
   };
           //  this与调用方式有关
</code></pre><p>再有：</p>
<pre><code>  Function.prototype  //    function () {}
    Function.protoype.demo = function () {
                 console.log(this); 
 };

   //可以通过Function这个函数访问到demo方法，

       Function.demo()        // function    Function() { [native code] }

        Function.prototype.demo()    //  function () {}
</code></pre><p> 所以，不是方法在那个对象中this就是哪个。</p>
<p> 函数调用的时候的this值  直接调用函数是this是全局对象而非该函数的外围的this值，ES6中有语法糖来处理这个问题。<br> 构造函数模式的this   new + 构造函数会形成一个对象，这里忽略其他细节；只讲this值，这时的this是新建立的那个对象</p>
<pre><code>   function foo (name) {
                    this.name = name;
  }

     var obj = new foo ();

  //也就是说foo执行时的this是obj,从而才有给obj添加name属性的可能
</code></pre><p>构造函数与一般函数没有区别，但是若一个函数建立的目的是用于建立对象，应当把其首字母大写；否则直接调用可能会给全局对象添加属性。<br>apply调用模式     函数是对象，所以可以有方法，apply/call就是方法。伪代码：function.apply(this,argumnets)，function.call(this,p1,p1,p1)。</p>
<h3 id="记忆"><a href="#记忆" class="headerlink" title="记忆"></a>记忆</h3><p> 记忆这种优化手段真是让人兴奋，它可以大大减少计算的工作量，例如在阶乘、裴波那契数列的计算中，若不采用优化，那浏览器甚至算不出来。采用优化后秒算出结果。下面是通用的记忆器</p>
<pre><code>    function memoizer (memo,formula) {
            var recur = function (n) {
                     var result = memo[n];
                    if ( typeof result !== &quot;number&quot;) {

                         result = formula();
                    memo[n] = result;
               }
                return result;   

            }
        return recur;
    }
</code></pre><p>JS的函数化很强大，这种方法在一个个函数的基础上差异化继承，也可以增强；也是建立部件的基础。实现对象与它的功能模块的扩充。建立对象与方法之间的松散耦合。</p>
<pre><code>  var o = {name:&quot;demo&quot;};
     var enhance = function (o) {
                 var that = o;
                  if ( !o.name) {
                          o.name = &quot;initial&quot;; 
           } 
                  if ( !o.get_name) {
                           o.get_name = function () {
                                  return o.name;    
                                    };              
          }
            return that;
 };
     var  b =  enhance(o);
</code></pre><hr>
<h2 id="五"><a href="#五" class="headerlink" title="五"></a>五</h2><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><strong>数组方法</strong><br><em>模拟队列</em>的操作：push()/shift();unshift()/pop();<em>模拟栈操作</em>：push()/pop(); push()返回增加后的长度、unshift也是。pop和shift返回项值。concat()在已有的数组基础上返回一个数组，即是传入的是数组，它也会将数组变成单一的参数。reverse（）没有用，join()将数组以某种分隔符的形式返回字符串。字符串的split可返回一个数组。<br> slice在字符串及数组上都会有，slice(n,n+p),p是复制数目。数组会得到一个数组，即是是空数组，这个方法可以处理负数。字符的subString()可以复制，但不支持数组，不建议用。splice()返回数组，会影响原来的数组，可以修改、添加、插入项与数组中，但效率不高。sort()默认基于编码大小，可以认为传入函数方便比较。</p>
<p><strong>Number的方法</strong><br>toString()。该方法将数字以基于几进制的形式输出。实现起来有bug.若是整数会出错(下面几个方法也是这样)，但若是浮点数形式没问题。存在变量中也不会有问题，故最好现存于变量中，如：23.toFixed(3) 会出错，而23..toFixed(3)就可使用。    toExponential()以科学计数法输出字符串，可指定小数点后的位数（0-20位）。有数字直接使用方法的可能。<br> toFixed()将数字指定小数点后的位数输出。     toPrecision()指定总的位数。</p>
<p><strong>正则表达式方法</strong><br>test()/exec();test()不建议使用g-flag。exec()好用，但慢（捕获较慢）。exec()返回一个数组，index0为匹配项，后面一次是捕获组、index、input。不用全局标识仅仅匹配第一次的。g标识下会一直向下，但只是每次匹配一项。</p>
<p><strong>字符串的操作</strong><br>字符串是最常见的操作。charAt()/charCodeAt()/String.fromCharCode()得字符串。concat()拼接。建议使用“+”。     查询：indexOf(text,position)/lastIndexOf()指定字符串及开始位置，返回位置；查询不到返回-1。search(exp)使用正则表达式，忽略g-flag,返回位置。<br>match()会返回一个数组，正则表达式中没有g同没有g的exec()方法；含g会有返回项各匹配项。replace(a，b)中a可以是字符串、正则表达式。b可以是函数、可以是字符串。同样，若不带g只会匹配第一项。为字符串时$有特殊含义。使用函数时，传入第一个参数是匹配项，然后是捕获组。<br>split()可以是字符串、正则表达式。是正则表达式时捕获组会加入数组。</p>
]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JS语言精粹 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[DOM简介]]></title>
      <url>/2016/08/27/dom-info.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>DOM是现在按W3C标准的浏览器均实现的标准。HTML、CSS、DOM共同在结构、表现、交互上共同支撑起一个页面。当然，必须以用户为中心、平稳退化、逐渐增强。DOM的操作是通过JS来实现的。JS最初在NN2中使用，在1997年以JS1.0为基础提交给ECMA,1998年提交到ISO/IEC。CSS1出现于1996年，规范有68页；1998年有了CSS2，规范有480页，实际并无CSS3的定义，通常指CSS level3规范以及新的第一版的某些模板规范，如同HTML5一样随着技术的迅速发展以后再划分代次并不合适。DOM1级产生于1998年。JS的迅速发展与2005年兴起的AJAX关系很大，又得益于google的v8引擎，使得js在服务器端的node.js迅速发展。</p>
<p>DOM是一种与平台、语言无关的API,是在该领域的约定就如同化学界的符号一样；可以通过一种编程语言对另一种标记语言的文档进行修改、删除、查询等操作。在1998年产生DOM1级前，就有实验性的DOM。IE4 NN4的DHTML概念很好，但是实现起来差异很大，简直是灾难。浏览器大战微软在其操作系统中捆绑IE而战胜NN。实际上NN的接班人是公益性质的firefox。2003年的safari以及chrome广泛使用的android的webkit引擎，firefox的Gecko引擎、Opera(原先是Prosto、后来是webkit)使得微软专有的Trident专有引擎向规范靠齐有了效果。IE9之后微软在这方面做得不错。</p>
<p>在操作DOM时，注意应当解析完了之后去用JS改变、查询；否则，这是一个不完整的DOM或许完不成应有的功能。window.onload = function () {do something;};</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于css的若干心得]]></title>
      <url>/2016/08/26/css-think.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p> css布局中定位机制主要是普通的流，也就是说按照HTML文本的顺序在窗口上从上到下、从左到右去显示，遇见块级元素就换行显示。为了更进一步的控制，我可以使用相对定位、绝对定位、固定定位以及浮动。</p>
<p> <strong>相对定位</strong>（position:relative）是相对于自身而言的，但会在原来的地方留出空白，所以不会影响后序的流；可能出现这个元素覆盖到其他元素上的情况发生。百分数表示的宽度相对于父元素的宽度而言的。</p>
<p> <strong>绝对定位</strong>(position:absolute)会让该元素从流中去掉，其他元素不会再看见它，可以产生覆盖的效果；其定位是相对于离它最近的的非普通流的父元素（position非static）的左上角，否则一直到原始的盒子可能是body。其百分数表示的宽度是源自于其定位元素的宽度的。通常在父元素中使用position:relative;子元素中使用position:absolute;</p>
<p> <strong>固定定位</strong>(position:fixed):这种定位是相对于浏览器窗口的，百分数表示的宽度也是相对于浏览器窗口的。该元素会从普通流中移除。</p>
<p> 这几种都可以设置z-index来改变各部分的相对屏幕位置。而且都可以在块级元素和内联元素上使用。</p>
<p>  <strong>float</strong>：在元素的父元素盒子里尽量向左或是右浮动，文本可以在周围浮动。而且，最好给一些元素加上宽度，否则会出现元素铺满整个盒子的情况发生。</p>
<p>  当一个包含元素内只直接包含有一个浮动元素，那么包含元素会被认为高度为0，可以使用overflow：auto;width:100%来改变这种状况。</p>
<p>   我们可以设置任何元素的margin，但是要使用margin:0px auto.使某个元素居中则要将这个元素设为块级元素。</p>
<blockquote>
<p><em>关于隐藏</em><br>  可以有diplay:none,这样会从流中去掉，可以将一个盒子的visibility:hidden.这样就不会显示盒子了，但盒子会继续占有那个位置，这个和empty-cells：hide的效果是一样的。<input type="hidden">可以隐藏这个控件。</p>
<p>背景关系：从下自上依次是：box-shadow(outer)、background-color、background-image、box-shadow（inset）、border。 </p>
<p> 一个网站必须要明确主要受众人群，网站主要功能；建立清晰易用的网站。其次，视觉层次很重要，浏览者未必想去翻看网页，他们需要快速找到内容。高视觉对比度就会更易突出线索。其次将相关内容组织起来更加让浏览者明白相应逻辑。其次，应当保持风格的协调、连贯性。借助相似的风格来建立一种默认的印象。</p>
<p>导航要做到：清晰、简洁、精选、连贯、交互好、告知位置。 </p>
<p>css已经拥有了80多项规范，这让其变得复杂，即使是w3c工作组css起草专家也难以说精通各方面；css已经形成了自己的开发者圈子、专业的技术会议、框架、工具链。原本看似简单的属性组合在一起之后变得极为复杂。索性的是各大浏览器如今都按照标准来（标准不只是强制的），这样得以按以下原则来设计代码：DRY、可维护、灵活、轻量级。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[css选择器]]></title>
      <url>/2016/08/20/css-selector.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>CSS（Cascading Style Sheet）通过与HTML元素的关联来改变元素的显示效果，这种实现是通过建立CSS规则来实现的。一条CSS规则包括：选择器+声明。如： p {font-family:Times,serif;}.P是选择器，花括号中是声明；声明包括属性与值。</p>
<blockquote>
<p>有以下几种类型：</p>
<ol>
<li>类型选择器。如h1,h2 {/<em>规则</em>/}</li>
<li>通用选择器。<em> {/</em>规则<em>/} ，“</em>”是常见的通配符</li>
<li>类选择器。.class {/<em>规则</em>/}</li>
<li>伪类/伪元素选择器。:link :visited :hover :focus :active :nth-child() :first-letter :first-line</li>
<li>ID选择器。#id {/<em>规则</em>/}</li>
<li>子选择器。如li&gt;a,仅仅用于li的直接的a</li>
<li>后代选择器。li a {/<em>规则</em>/},适用于li 所有的a元素</li>
<li>相邻兄弟选择器。如：h2+p {/<em>规则</em>/},适用于与h2同一个父元素的直接相邻的且在h2后面的P</li>
<li>普通兄弟选择器。如：h2~p {/<em>规则</em>/},适用于与h2同一个父元素的在h2后面的P</li>
<li>特性选择器。如：p[class] p[class=”important”] p[class~=“important”] p[attr^”dd”] p[attr*”ds”] p[attr$”end”]</li>
</ol>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS简要说明]]></title>
      <url>/2016/08/10/JS-intro.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="JS趣谈"><a href="#JS趣谈" class="headerlink" title="JS趣谈"></a>JS趣谈</h2><p>JavaScript是一门最易让人误解的语言，该语言中精华与糟粕并存（可能比一般语言的这个比例要大一些）；但“千淘万漉虽辛苦，吹尽黄沙始到金”，层层面纱下是易用灵活、优雅轻灵的内在。很久以前，JavaScript被当做是玩具语言，直到AJAX的出现，直到V8引擎的易用；这种局面已经改变。</p>
<p>JavaScript诞生于1995年（那时我还很小）；一个叫Brendan Eich的人设计了这种语言。他就职于Netscape公司，他说服了老总要开发这种语言。然而仅用了10天，10天。这门语言最初是用于解决服务器端语言（Perl等）要处理的表单验证操作。为什么呢？在通过“猫”（modem）拨号上网的年代，网速只有28.8kbit/s啊。你填一个表格之类的若填错了或填写的没填，你提交数据就只有等着吧，等了半天啥也干不了；可能最悲催的是你可能受到一个通知，你填的不对啊（心里一万匹草泥马奔过）。这里可见在客户端能验证一下多有用了吧。</p>
<p>JavaScript与Java的关系如同“雷锋”与“雷峰塔”。要说有关系，那就是炒作关系。当年Netscape与Sun(Sun与Java关系那叫一个紧密)何种开发了JavaScript，当时Java正炒得热，那就将其命名为JavaScript吧。JavaScript从诞生就迅速被接受，没有经过实验室的严格测试，加之完成的时间短，语言本身问题很多。1996年，NN4 中推出了JS1.1版本，而IE3虽有VBScript，但支持了JScript(但是逆向的JS1.0)。因为没有事实的标准，这二者之间很多地方并不一致。1997年，一个基于JS1.1的方案提交给了ECMA，ECMA让TC#39负责实现一种供应商中立、通用、跨平台的脚本语言的语法、语义。TC#39给了ECMA-262标准（针对ECMAScript）。1998，ISO/IEC接受了这个标准。</p>
<p>ECMAScript未定义语言的I/O,故可以以它为核心扩展。JavaScript只是其中一种，还用Adobe ActionScript等等，服务器端还有Node。JavaScript包括：ECMAScript、DOM、BOM。</p>
<p>那ECMAScript定义了哪些内容呢？语法、语句、类型、关键字、保留字、对象、操作符。ECMAScript对其兼容性做了定义：1、要支持Unicode（支持多语言开发）2、支持定义的类型、值、对象、属性、函数、句法的等 3、可以扩展未定义的类型、值、对象、属性、函数、句法等 4、支持对未定义的正则表达式、程序的支持。还是比较开放的。就对其支持而言，JS1.1及JS1.2都不完全支持ECMAScript 1;JS1.3是第一个完全支持的。IE3申称支持，但实际上也并非如此吧！JS1.4也仅仅支持服务器端，NN的继承者Firefox开始于版本号JS1.5。通常，以对ECMAScript及DOM的支持来衡量浏览器的兼容性，因为命名规则混乱。</p>
<p>ECMASript已有6版了，第一版在JS1.1基础上支持Unicode,支持与平台无关的对象。第二版为与ISO/IEC一致仅仅做了一些编辑工作。第三版新增：对字符串的处理、正则表达式、新的控制语句、try-catch语句、错误类型、数值输出。第四版由于与第三版差距太大而放弃;以以下面一个3.1方案代替（ECMAScript 5）.第五版支持原生JSON对象、“继承”以及高级属性；包含一个严格模式（对引擎解释执行代码进行补充）。</p>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>DOM（文档对象模型，发布于1998年）：针对于XML并扩展到HTML通用的、跨平台的API。它将文档结构映射为多层次的结构。DOM的出现时为了应对IE以及当年NN的一家独大。它们搞了DHTML的概念，但是实现起来却各不相同。这样要想跨平台就要编写多个文档了。但实际上DOM也并不清晰。目前DOM分为三级,DOM0级指的是历史概念表示当时对DHTML的各自支持。</p>
<ol>
<li>DOM level1：含Core(实现XML文档映射)、HTML（基于Core的扩展，添加了对象、方法）；</li>
<li>DOM level2：Core扩展对命名空间支持，添加Views、Events、Style、Range and Traversal模块；</li>
<li>DOM level3：Core支持XML1.0（支持XML infoset、XML Xpath、XML Base）,加入了Load and Save、Validation模块。</li>
</ol>
<p>其他语言还支持SVG、MathXML、SMIL。IE5开始着手支持DOM，但是IE5.5才完全支持；IE6、7在吃老本；IE8修复了bug，IE8第一个着手支持ECMASript5,IE9已经完全支持了（微软还是有进步）。</p>
<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p>  BOM只是支持对框架、窗口的操作；但把其他一些针对浏览器的操作也算在里面了，比如：</p>
<p>   1、弹出新窗口；2、移动、关闭、缩放窗口；3、对cookie的支持；4、支持navigator对象；5、支持screen对象；6、支持location；7、自定义的XMLHttpRequest和ActiveXObject。</p>
<p>最初的BOM与浏览器紧密关联，不同的浏览器有不同的实现。HTML5才对其做出了规范。（完） </p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS原型链的一点看法]]></title>
      <url>/2016/07/30/JS-prototype.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>JavaScript借鉴了许多语言的特点例如语法类Java、函数借鉴Scheme、原型继承借鉴自Self、<br>正则表达式借鉴于Perl。（DC Javascript：语言精粹。</p>
<p>首先，每个JS是一门基于原型继承的面向对象的语言。<br>里面数组是对象、函数是对象、“对象”当然还是对象。而且每个对象都有一个internal slot[[prototype]],这才是原型链连接起来的关键。诚然，我们可以为一个对象设置prototype property,但这又怎么样呢，这只是表象；后面暗藏杀机。</p>
<pre><code>举个例子：

        //建立一个函数

        function foo () {} 

       //修改函数的prototype property    

       foo.prototype = {

                 name : &quot;foo.prototype&quot; 
                            };
         //建立一个实例  

           var a = new foo();

       //重写 a 的默认原型，本应该是foo.prototype.
             a.prototype = {
                  name : &quot;a.prototype&quot;
           };
</code></pre><p> 下面的问题是foo.prototype是不是a的原型呢？!</p>
<p> 这要分开来看：一方面a.prototype确实是{ name : “a.prototype”};但是，foo.prototype.isPrototypeOf(a)结果是true.<br> 下面来看一看具体的关系：(使用—&gt;表示不明显的[[prototype]]链,—表示prototype property关系)</p>
<pre><code>         Function ---&gt; Function.prototype---&gt;Object.prototype    
         Function.prototype &lt;--- foo---foo.prototype ------&gt;Object.prototype 。              
</code></pre><p>另外，Number、Boolean、String等的[[protptype]]仍然是Fuction.prototype对象。Function.prototype对象为“function”，内部不含[[construct]]故而不可做构造函数用；实际上Function.prototype类似：function （） {}。“function”类型除了[[prototype]]internal slot外，<br>还有prototype属性。每个函数总是相伴有一个prototype对象：this.prototype = {constructor:this}(一个普通对象)。这个普通对象的[[prototype]]连接到Object.prototype.</p>
<p>那构造函数建立的实例对象的[[prototype]]是Object.prototype吗？</p>
<p>该实例的[[prototype]]是由构造函数的prototype property初始化的，注意不是函数的[[prototype]].所以如果是由Object这个函数构造的对象，那么就确实是.</p>
<p>  Object是函数，它的prototype是大名鼎鼎的Object.prototype(有点废话的意思)，但是它的[[prototype]]指向Function.prototype.请看下面：</p>
<pre><code>     Object-----&gt;Function.prototype------&gt;Object.prototype.
</code></pre><p>如何改变这个[[prototype]]链呢？    可以采用var a = Object.create(obj)的形式，或Object.setPrototypeOf(objA,objB)的形式。我想例子就不用举了，因为关系很简单；况且我只举得出一些蹩脚的例子。没有意义。</p>
<p>   最后一个问题，行为委托是基于[[prototype]]链吗？<br>   是的，也是这样。</p>
]]></content>
      
        <categories>
            
            <category> JS </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[学习JavaScript DOM编程艺术的心得]]></title>
      <url>/2016/06/02/domthink.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p> 最近又看了一遍JS DOM编程艺术，照例来写一写读后感。</p>
<p> 其实，我从中学到最深的是几个概念：1、平稳退化。当浏览器并不支持JS的时候网页的基本核心功能是还可以用的；2、逐渐增强。在原始的信息层上用其他层去增加其他信息。用CSS去增加效果，用JS去添加行为。当然某些浏览器可以支持部分的js,为了使旧浏览器可以用，不至于因为某些代码挂掉。3、将结构、表现、行为分离，而且分离越大越好。</p>
<p>  然后我学到了简单的一点关于对象检测的技术，这在运用向后兼容原则时必要的，但文章太过保守，像：document.getElementsByTagName等也在检测。或许在老古董的浏览器上有用，但现在基本无用。其次，文中说可以从：减少访问DOM及添加标记、合理合并脚本（减少请求）、合理放置脚本位置、压缩脚本等几个方面提高性能。</p>
<p>  或许还让我了解了一点AJAX，文中显示建立了一个XMLHttpRequest对象、然后用该对象来发送请求接受响应，但是这是异步的。其中运用了事件监听，而这是其异步的根源。因为，就如同onclick、onmouseover等事件一样，该函数不会立即执行，它会加入到任务队列之中而非主线程，而JS是单线程的。必须要待主线程空了之后才有可能执行。另，setTimeout和setInterval也是添加到任务队列中。计时是相对于主线程空的计时，计时是可以中断的，待主线程有了任务它就暂停计时。</p>
<p>   以上就是我认为于我有益的东西。<br>   大家对本书评价很高，确实是入门的好选择，但最好是对HTML和CSS有所了解、对JS语言的语法本身有所了解就更好；否则一开头还是有点困难。所以，一开头还是先学HTML、CSS；然后将高程关于JS语言本身的部分看完再回头学效果更好。</p>
<p>我自己练习的时候遇到一个问题:Failed to load resource: net::ERR_FILE_NOT_FOUND。这是什么原因呢？路径的问题，我是动态的产生元素，但我以为图片的src应该是相对于我的js文件的相对路径。但事实是建立的元素经过浏览器渲染之后实际好像就是原来就在这里一样，当然路径应该是相当于html的相对路径了，若是使用绝对的URL不存在问题。</p>
]]></content>
      
        <categories>
            
            <category> 编程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
        
    </entry>
    
  
  
    
    <entry>
      <title><![CDATA[关于我]]></title>
      <url>/about/index.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p>二十年前的某个春日的某个西南山村，一个男婴呱呱坠地了…</p>
<p>他开始上学了。学校掩映于田畴之中，这些石头房子是学校租的。上课的时候十里八村的小伙伴们都往这里赶。某天转学回来了同学，说是武校的。那个班主任让他教他们练武，他们就稀里哗啦胡乱比划一通，管他什么动作。这是他们课间日常。放学后他走在乡间小路上，脑子空空啥也不想；或许想一些蚂蚁为什么打架的东西吧。路边的油菜花开了，蜜蜂成群飞舞，迎面是菜花的香。山村屋子上冒着白烟，远处山上一抹残阳。</p>
<p>他性格内向，好看书。一有时间他就趴着躺着看是书，他享受这个宁静的世界，也享受知识对内心的滋养。小山村晚上的娱乐活动是看电影。那时流行武侠，像侠客行、射雕啦，另外是琼瑶的作品。男孩子们当然看完后得模仿模仿，他们会削木剑然后在田里打斗一番。玩得满身大汗。得等到家长叫吃饭他们才散去。他有时会和父亲一起上山找天麻，跑了很久他一个也没找到；他内心很愉快，喜欢下过雨后的竹林。他有时也会和母亲一起干点活，母亲总是比较坚韧又慈爱的。他还有个弟弟，虽然顽皮但是坚毅，他们度过了人生中那段艰苦又美好的日子。</p>
<p>夏日，他在家中翻出了一个老式的音乐播放器，尽然能用。然后音乐就走进了他的世界。他凭借着一股刻苦学习的劲儿，在初中也屡次获得点奖金。他虽然歌喉不怎么样，但他热爱音乐。他通常会在周五的下午去买上一盒磁带，然后满足地回家听上很久；他觉得音乐的世界神奇极了。他有段时间迷上了英语口语就拼命的练习，在路上，在天野…甚至在晚上说梦话也是英语。</p>
<p>大学是他人生中的一个重要节点。在这里，他看了许多书，他看到了许多以前没有看过的东西，想了许多以前没想过的问题。他某段时间特别激进特别忧国忧民，看来还是不成熟。他看了许多记录片，想从中汲取力量；然而许多沉重的东西压得他喘不过气来。他渐渐明白了这句话的分量：世界上只有一种真正的英雄主义，就是认清了生活的真相后还依然热爱它。他与自己达成和解，他变得平和了。他依然热爱音乐，热爱各种美好的东西。他偶然间接触到了吉他，他就学了吉他。虽然弹得不好，他还是很喜欢。他以前连自行车也不会骑。这挡不住他的兴趣，他买了个二手自行车<br>用了一上午的时间学会了骑自行车….</p>
<p>他上了研，这里他上了许多课结识了许多朋友；他在这段时间疯狂的阅读，他觉得充实。这段时间他对编程产生了兴趣，我知道编程会成为他生命中重要的一部分的。我写了这些文字，我突然意识到我是不看不见后面的，他的人生才开了个头:未来更加值得期待。但我知道他在对真善美的追求，对自我完善的路上会越州越远。</p>
<audio src="http://music.163.com/#/outchain/2/491295324/" controls="controls"> 您的播放器不自持</audio>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用图片记录生活]]></title>
      <url>/gallery/index.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[友情链接]]></title>
      <url>/links/index.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[标签云]]></title>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[timeline]]></title>
      <url>/timeline/index.html</url>
      <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script>]]></content>
    </entry>
    
  
</search>
